#include "compile.h"

void readin();
void Intersection(string &a,string b);
string Getf(int v,int & H0);
void Getfirst();
void Printfirst();
void Getfollow();
void Printfollow();
void Gettable();
string Getp(int i);
void PrintT();

map<string,int> Getnu;//用标号记录每个非终结符和终结符
string Getch[100];//标号对应的非终结符和终结符
vector<string> Process;//单个生成式组合，例如A->bAc存储为A bAc先读取非终结符，空格分开，后面为表达式
vector<string> Production;//存储去掉首的非终结符
int table[100][100];//分析表
int num=0;//终结符加上非终结符的数量
int numvt=0; //终结符和非终结符分界点，改标号表示的是空，用@表示
string first[100];
string follow[200];
string word;
vector<string> process1;

void readin()
{
    memset(table,-1,sizeof(table));
    Getnu["#"]=0;
    Getch[0]="#";
    ifstream fp;
    fp.open("zhongjie.txt");
    if(!fp.is_open()) 
    {
        cout<<"error"<<endl;
        return;
    }
    string x;
        do{
           fp>>x;
            Getnu[x]=++num;
            Getch[num]=x;
        }while(!fp.eof());
    fp.close();
    numvt=++num;
    Getnu["@"]=numvt;       
    Getch[num]=("@");
    fp.open("nozhongjie.txt");
    if(!fp.is_open()) 
    {
        cout<<"error"<<endl;
        return;
    }
        do{
            fp>>x;
            Getnu[x]=++num;
            Getch[num]=x;
        }while(!fp.eof());
    fp.close();
    fp.open("chanshengshi.txt");
    if(!fp.is_open()) 
    {
        cout<<"error"<<endl;
        return;
    }
    string pro,head,ss,dd;//head为开头非终结符(单词)，pro为表达式的一个单词，ss为整个表达式，表达式由|分开
    ss.clear();
    dd.clear();
        while(fp>>head && head!="end")//读取开头的非终结符(单词)连带后面的多个产生式
        {
            dd.clear();
            ss=head;
            fp>>pro;//除去->
            do{
                fp>>pro;
                if(pro == "|")
                {
                    Process.push_back(ss);
                    Production.push_back(dd);
                    dd.clear();
                    ss.clear();
                    ss=head;
                }
                else
                {
                    ss=ss+" "+pro;
                    if(dd=="") dd+=pro;
                    else dd=dd+" "+pro;
                }
            }while(fp.peek()!='\n');
            Production.push_back(dd);
            Process.push_back(ss);
        }
}

string Gainfirst(string sb)//获取process的非终结符首
{
    string ss;
    int i=0;
    while(sb[i]!=' ')
    {
        ss+=sb[i];
        i++;
    }
    return ss;
}

string Gainsecond(string sb)//获取process的右式首词
{
    string ss;
    int i=0;
    while(sb[i++]!=' ') {}
    while(sb[i]!=' ' && i<sb.size())
    {
        ss+=sb[i];
        i++;
    }
    return ss;
}

void Intersection(string &a,string b) //取a,b交集赋值给a
{
    set<char>SETE;
    for(int i=0;i<a.size();i++) SETE.insert(a[i]);
    for(int i=0;i<b.size();i++) SETE.insert(b[i]);
    string SS;
    set<char>::iterator I;
    for(I=SETE.begin();I!=SETE.end();I++) SS+=*I;
    a=SS;
}

string Getf(int v,int & H0)//求first集时首尾情况考虑
{
    if(v==numvt)
    {
        H0=1;
    }
    if(v<numvt) return first[v];
    string SS;
        for(int i=0;i<Process.size();i++)
        {
            if(Getnu[Gainfirst(Process[i])]==v) 
            {
                string Second;
                int t=0;
                while(Process[i][t]!=' ') ++t;
                ++t;
                while(Process[i][t]!=' ' && t!=Process[i].size())
                {
                    Second+=Process[i][t];
                    ++t;
                }
                SS+=Getf(Getnu[Second],H0);
            }
        }
    return  SS;
}

void Getfirst()//得到first集
{
    for(int i=1;i<=numvt;i++)
    {
         first[i]+=('0'+i);//非终结符事先加上‘0’的ascii码
    }
    for(int j=0;j<Process.size();j++)
    {
        int k=0;int H0=0;
        while(Process[j][k]!=' ') k++;//跳过第一个终结符记录
            do{
                H0=0;
                k++;
                    if(k>=Process[j].size())  
                    {
                        first[Getnu[Gainfirst(Process[j])]]+=('0'+numvt);
                        break;
                    }
                string ss;
                while(Process[j][k]!=' ')
                {
                    ss+=Process[j][k];
                    k++;
                    if(k>=Process[j].size())
                    {
                        Intersection(first[Getnu[Gainfirst(Process[j])]],Getf(Getnu[ss],H0));
                        break;
                    }
                }
                Intersection(first[Getnu[Gainfirst(Process[j])]],Getf(Getnu[ss],H0));
                ss.clear();
            }while(H0);
    }
}

void Printfirst()//打印first集
{
    cout<<"first集:"<<endl;
    for(int i=1;i<=num;i++)
    {
        cout<<"first ["<<Getch[i]<<"]: ";
        for(int j=0;j<first[i].size();j++) cout<<Getch[first[i][j]-'0']<<" ";
        cout<<endl;
    }
    cout<<endl;
}

void Getfollow()//得到follow集
{
    Intersection(follow[Getnu[Gainfirst(Process[0])]],"0");//首个加入#
    for(int j=0;j<Process.size();j++)
    {
        int jj=0;
        while(Process[j][jj++]!=' '){}//跳过左式终结符
        for(;jj<Process[j].size();jj++)
        {
            string ss,hehe;
            while(Process[j][jj]!=' ' && jj<Process[j].size())
            {
                ss+=Process[j][jj];
                jj++;
            }
            if(Getnu[ss]<=numvt)
            {
                ss.clear();
                continue;
            }
            int k=jj; 
            int H0;
            do
            {
                hehe.clear();
                H0=0;
                k++;
                if(k>=Process[j].size())
                {
                    Intersection(follow[Getnu[ss]],follow[Getnu[Gainfirst(Process[j])]]);
                    break;
                }
                while(Process[j][k]!=' ')
                {
                    hehe+=Process[j][k];
                    k++;
                    if(k>=Process[j].size())
                    {
                        break;
                    }
                }
                Intersection(follow[Getnu[ss]],Getf(Getnu[hehe],H0));
            }while(H0);
        }
    }
}

void Printfollow()//打印follow集
{
    cout<<"follow集："<<endl;
    for(int i=numvt+1;i<=num;i++)
    {
        cout<<"follow ["<<Getch[i]<<"]: ";
        for(int j=0;j<follow[i].size();j++) cout<<Getch[follow[i][j]-'0']<<" ";
        cout<<endl;
    }
    cout<<endl;
}

void Gettable()
{
    for(int i=0;i<Process.size();i++)
    {
        if(Gainsecond(Process[i])=="@")
        {
            string Follow=follow[Getnu[Gainfirst(Process[i])]];
            for(int k=0;k<Follow.size();k++)
            {
                table[Getnu[Gainfirst(Process[i])]][Follow[k]-'0']=i;
            }
        }
        string temp=first[Getnu[Gainsecond(Process[i])]];
        for(int j=0;j<temp.size();j++)
        {
            if(temp[j]!=(numvt+'0'))
            {
                table[Getnu[Gainfirst(Process[i])]][temp[j]-'0']=i;
            }
            else
            {
                string Follow=follow[Getnu[Gainsecond(Process[i])]];
                for(int k=0;k<Follow.size();k++)
                {
                    table[Getnu[Gainfirst(Process[i])]][Follow[k]-'0']=i;
                }
            }
        }
    }
}

string Getp(int i)
{
    string ss;
    ss=to_string(i);
    return ss;
}

void PrintT()
{
    cout<<"预测分析表："<<endl;
    string ss;
    int t;
    cout<<left<<setw(12)<<" ";
    for(int i=0;i<numvt;i++)
        {
            ss=Getch[i];
            t=ss.size();
            cout<<left<<setw(t+2)<<ss;
        }
        cout<<endl;
    for(int i=numvt+1;i<=num;i++)
    {
        cout<<left<<setw(12)<<Getch[i];
        for(int j=0;j<numvt;j++)
        {
            ss=Getch[j];
            t=ss.size();
            cout<<left<<setw(t+2)<<Getp(table[i][j]);
        }
        cout<<endl;
    }
    cout<<endl;
}
void initProcess()
{
    ifstream file;
    char* filename="chanshengshi1.txt";
    file.open(filename,ios::in);
    if(!file.is_open())
        return ;
    string strline;
    while(getline(file,strline))
    {
        process1.push_back(strline);
    }
    file.close();
}
int main()
{
    readin();
    Getfirst();
    Printfirst();
    Getfollow();
    Getfollow();
    Printfollow();
    Gettable();
    PrintT();
    system("pause");
    return 0;
}